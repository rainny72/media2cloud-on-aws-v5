// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const {
  agnes,
} = require('ml-hclust');
const {
  toHHMMSS,
} = require('../commonUtils');
const {
  MAXTIMEDISTANCE,
  MINSCENEDURATION,
  MAXSCENEDURATION,
  TYPE_BLACKFRAMES,
} = require('./definitions');
const {
  timeIntersected,
} = require('../simpleGeometry');

const KNOWN_TYPES = [TYPE_BLACKFRAMES];
const WINDOWSIZE = 300000; // 5mins
const OVERLAPSIZE = 60000; // 1min

const EnableDynamicThreshold = false;

function _mapCandidateToFrameClusters(candidate, frames) {
  const {
    nClusters, height, gap, frameIndices,
    frameMinMax: [fmin, fmax],
    durationMinMax: [dmin, dmax],
  } = candidate;
  console.log(`=== Choosing ${nClusters} clusters w/ ${height.toFixed(4)} height, ${gap.toFixed(4)} gap, [${fmin}/${fmax}] frame range, & [${toHHMMSS(dmin, true)}/${toHHMMSS(dmax, true)}] duration range.`);

  // mapping indices to actual frames in cluster
  const frameClusters = [];

  for (const indices of frameIndices) {
    const framesInCluster = [];
    for (const index of indices) {
      framesInCluster.push(frames[index]);
    }
    framesInCluster.sort((a, b) => a.timestampMillis - b.timestampMillis);
    frameClusters.push(framesInCluster);
  }

  return frameClusters;
}

function _getOptimalHeights(tree, topN = 10) {
  const heights = _getHeightRecursively(tree);
  heights.sort((a, b) => a - b);

  let gaps = heights.slice(1).map((h, i) => ({
    gap: h - heights[i],
    height: heights[i],
  }));

  gaps.sort((a, b) => b.gap - a.gap);

  // Top ranked heights
  const topRanked = gaps.slice(0, topN).map(({ height, gap }) => ({
    height: height,
    gap: gap
  }));

  return topRanked;
}

function _getHeightRecursively(node, heights = []) {
  if (node.children) {
    const height = node.height;
    heights.push(height);
    for (const child of node.children) {
      _getHeightRecursively(child, heights);
    }
  }
  return heights;
}

function _validateClusterTemporal(clusters, maxTimeDistance) {
  let validated = [];

  for (const cluster of clusters) {
    const groupByTimestamps = _breakOnDiscontinuity(cluster, maxTimeDistance)
    for (const subGroup of groupByTimestamps) {
      validated.push(subGroup);
    }
  }

  validated = _mergeOnOverlapTimestamp(validated);
  for (const cluster of validated) {
    cluster.sort((a, b) => a.timestampMillis - b.timestampMillis);
  }

  console.log(`=== Validate cluster temporal: ${clusters.length} -> ${validated.length}`);
  return validated;
}

function _mergeOnOverlapTimestamp(clusters = []) {
  if (clusters.length === 0) {
    return [];
  }

  let clusterId = 0;
  const timestamps = [];

  for (const cluster of clusters) {
    cluster.sort((a, b) => a.timestampMillis - b.timestampMillis);
    const start = cluster[0].timestampMillis;
    const end = cluster[cluster.length - 1].timestampMillis;
    timestamps.push({ start, end, indices: [clusterId++] });
  }
  timestamps.sort((a, b) => a.start - b.start);

  const merged = [timestamps[0]];
  for (let i = 1; i < timestamps.length; i += 1) {
    const pre = merged[merged.length - 1];
    const cur = timestamps[i];
    if (cur.start <= pre.end) {
      pre.end = Math.max(pre.end, cur.end);
      pre.start = Math.min(pre.start, cur.start);
      for (const idx of cur.indices) {
        pre.indices.push(idx);
      }
    } else {
      merged.push(cur);
    }
  }

  const mergedClusters = [];

  for (const { indices } of merged) {
    const idxs = [...new Set(indices)];
    let cluster = [];
    for (const idx of idxs) {
      cluster = cluster.concat(clusters[idx]);
    }
    cluster.sort((a, b) => a.timestampMillis - b.timestampMillis);
    mergedClusters.push(cluster);
  }

  return mergedClusters;
}

function _breakOnDiscontinuity(data = [], maxThreshold = MAXTIMEDISTANCE) {
  if (data.length === 0) {
    return [];
  }

  if (data.length < 2) {
    return [data];
  }

  const sorted = data.sort((a, b) => a.timestampMillis - b.timestampMillis);
  const threshold = _discontinuityThreshold(sorted, maxThreshold);

  const groups = [];
  let curGroup = [sorted[0]];

  for (let i = 1; i < sorted.length; i++) {
    const gap = sorted[i].timestampMillis - sorted[i - 1].timestampMillis;
    if (gap >= threshold) {
      groups.push(curGroup);
      curGroup = [];
    }
    curGroup.push(sorted[i]);
  }

  if (curGroup.length) {
    groups.push(curGroup);
  }

  return groups;
}

function _discontinuityThreshold(data = [], maxThreshold = MAXTIMEDISTANCE) {
  if (!EnableDynamicThreshold) {
    return maxThreshold;
  }

  // dynamically compute the threshold
  let diffs = [];
  for (let i = 1; i < data.length; i++) {
    diffs.push(data[i].timestampMillis - data[i - 1].timestampMillis);
  }

  const filtered = diffs.filter((d) => d > 1001);
  if (filtered.length) {
    diffs = filtered;
  }
  diffs.sort((a, b) => a - b);

  const q1 = Math.floor((diffs.length / 4));
  const q3 = diffs[Math.floor((diffs.length * 3) / 4)];
  diffs = diffs.slice(q1, q3);

  const threshold = diffs.reduce((a, b) => a + b, 0) / diffs.length;
  console.log(`=== discontinuity threshold: ${threshold}`);

  return threshold;
}

function _getClusterCandidates(frames = []) {
  frames.sort((a, b) => a.timestampMillis - b.timestampMillis);

  const duration = frames[frames.length - 1].timestampMillis - frames[0].timestampMillis;
  console.log(`=== Clustering ${frames.length} frames, ${toHHMMSS(duration, true)} in duration.`);

  const embeddings = frames.map(({ embedding }) => embedding);
  const tree = agnes(embeddings, { method: 'ward2' });

  const topRanked = _getOptimalHeights(tree, 10);
  let candidates = [];

  for (const { gap, height } of topRanked) {
    const clusters = tree.cut(height);

    const frameMinMax = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];
    const durationMinMax = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];
    const frameIndices = [];

    for (const cluster of clusters) {
      const ids = cluster.indices().sort((a, b) => a - b);

      const numFrames = ids.length;
      frameMinMax[0] = Math.min(frameMinMax[0], numFrames);
      frameMinMax[1] = Math.max(frameMinMax[1], numFrames);

      const duration = frames[ids[numFrames - 1]].timestampMillis - frames[ids[0]].timestampMillis;
      durationMinMax[0] = Math.min(durationMinMax[0], duration);
      durationMinMax[1] = Math.max(durationMinMax[1], duration);

      frameIndices.push(ids);
    }

    candidates.push({
      frameMinMax,
      durationMinMax,
      gap,
      height,
      nClusters: clusters.length,
      frameIndices,
    });
  }

  return candidates;
}

function _formClustersWithMostNodes(candidates, frames, minSceneDuration = MINSCENEDURATION, maxSceneDuration = MAXSCENEDURATION) {
  let duped = candidates.slice();

  // filter out candidates that are too lomg
  let start = Math.floor(maxSceneDuration / 2);
  let step = 30000;
  for (let duration = start; duration < maxSceneDuration; duration += step) {
    const filtered = duped.filter((candidate) => candidate.durationMinMax[1] < duration);
    if (filtered.length) {
      duped = filtered;
      break;
    }
  }

  // filter out candidates that are too short
  start = minSceneDuration;
  step = 1000;
  for (let duration = start; duration >= 0; duration -= step) {
    const filtered = duped.filter((candidate) => candidate.durationMinMax[0] >= duration);
    if (filtered.length) {
      duped = filtered;
      break;
    }
  }

  // // filter out candidates that don't have enough frames
  // for (let minFrames = MIN_FRAMES_PER_SCENE; minFrames >= 0; minFrames -= 1) {
  //   const filtered = duped.filter((candidate) => candidate.frameMinMax[0] > minFrames);
  //   if (filtered.length) {
  //     duped = filtered;
  //     break;
  //   }
  // }

  duped.sort((a, b) => b.nClusters - a.nClusters);
  return _mapCandidateToFrameClusters(duped[0], frames);
}

// function _formClustersWithLongestDuration(candidates, frames) {
//   let duped = candidates.slice();

//   duped.sort((a, b) => b.durationMinMax[1] - a.durationMinMax[1]);
//   return _mapCandidateToFrameClusters(duped[0], frames);
// }

function _mergeClusters(clusters) {
  const merged = [];

  let curGroup = clusters[0];
  for (let i = 1; i < clusters.length; i += 1) {
    const pre = curGroup;
    const cur = clusters[i];
    const preTimestamps = [pre[0].timestampMillis, pre[pre.length - 1].timestampMillis];
    const curTimestamps = [cur[0].timestampMillis, cur[cur.length - 1].timestampMillis];
    if (!timeIntersected(preTimestamps, curTimestamps, false)) {
      merged.push(curGroup);
      curGroup = cur;
      continue;
    }

    // merge the timestamps
    const frameNums = pre.map((frame) => frame.frameNum);
    for (const frame of cur) {
      if (frameNums.includes(frame.frameNum) === false) {
        pre.push(frame);
      }
    }
    pre.sort((a, b) => a.timestampMillis - b.timestampMillis);
  }

  if (curGroup.length > 0) {
    merged.push(curGroup);
    curGroup = [];
  }

  console.log('********* MERGED *********');
  let clusterId = 0;
  for (const cluster of merged) {
    const start = cluster[0].timestampMillis;
    const end = cluster[cluster.length - 1].timestampMillis;
    const duration = end - start;
    console.log(`=== CLUSTER${String(clusterId++).padStart(3, '0')}: ${toHHMMSS(start, true)} -> ${toHHMMSS(end, true)} [${toHHMMSS(duration, true)}]`);
  }

  return merged;
}

function _groupFrameShotsByKnownTypes(framesToShots) {
  const groupsByKnownTypes = [];
  let curGroup = [framesToShots[0]];

  for (let i = 1; i < framesToShots.length; i += 1) {
    const pre = curGroup[curGroup.length - 1];
    const cur = framesToShots[i];

    if (pre[0].knownType === cur[0].knownType) {
      curGroup.push(cur);
      continue;
    }

    if (KNOWN_TYPES.includes(pre.knownType) && KNOWN_TYPES.includes(cur.knownType)) {
      const preFrame = pre[0].frames[pre[0].frames.length - 1];
      const curFrame = cur[0].frames[0];
      const preColor = (preFrame.colorProps || {}).dominantColorName;
      const curColor = (curFrame.colorProps || {}).dominantColorName;

      if (preColor === curColor) {
        curGroup.push(cur);
        continue;
      }
    }

    groupsByKnownTypes.push(curGroup);
    curGroup = [cur];
  }

  if (curGroup.length > 0) {
    groupsByKnownTypes.push(curGroup);
    curGroup = [];
  }

  return groupsByKnownTypes;
}

async function _agnesClusterFramesToScenes(framesToShots = [], filterSettings = {}) {
  if (framesToShots.length === 0) {
    return [];
  }

  const {
    minSceneDuration = MINSCENEDURATION,
    maxSceneDuration = MAXSCENEDURATION,
    maxTimeDistance = MAXTIMEDISTANCE,
  } = filterSettings;

  let framesToClusters = [];

  const windowSize = WINDOWSIZE;
  const overlapSize = OVERLAPSIZE;

  let shotGroups = _groupFrameShotsByKnownTypes(framesToShots);
  for (const shotGroup of shotGroups) {
    if (KNOWN_TYPES.includes(shotGroup[0][0].knownType) || shotGroup.length === 1) {
      framesToClusters.push(shotGroup.flat(1));
      continue;
    }

    const frames = shotGroup.flat(1);
    while (frames.length) {
      let framesToRemove = 1;
      const sliced = [frames[0]];
      for (let i = 1; i < frames.length; i += 1) {
        const frame = frames[i];
        const duration = frame.timestampMillis - sliced[0].timestampMillis;
        if (duration <= (windowSize - overlapSize)) {
          framesToRemove += 1;
        }
        if (duration > windowSize) {
          break;
        }
        sliced.push(frame);
      }

      // run clustering logic
      const candidates = _getClusterCandidates(sliced);
      let granularClusters = _formClustersWithMostNodes(candidates, sliced, minSceneDuration, maxSceneDuration);
      granularClusters = _validateClusterTemporal(granularClusters, maxTimeDistance);
      for (const cluster of granularClusters) {
        framesToClusters.push(cluster);
      }
      frames.splice(0, framesToRemove);
    }
  }

  console.log(`===== Clusters using Granular Cluster Formation ====`)
  framesToClusters.sort((a, b) => a[0].timestampMillis - b[0].timestampMillis);
  framesToClusters = _mergeClusters(framesToClusters);

  return framesToClusters;
}

////////////////////////////////////////////////////
// Functions to export
////////////////////////////////////////////////////
async function agnesClusterFramesToScenes(framesToShots, filterSettings) {
  return await _agnesClusterFramesToScenes(framesToShots, filterSettings);
}

module.exports = {
  agnesClusterFramesToScenes,
};
