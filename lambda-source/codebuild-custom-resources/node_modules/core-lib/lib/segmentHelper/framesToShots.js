// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const {
  cosim,
} = require('../simpleMath');
const {
  toHHMMSS,
} = require('../commonUtils');
const {
  TYPE_BLACKFRAMES,
  TYPE_MONOCHROMEFRAMES,
  MINFRAMESIMILARITY
} = require('./definitions');
const {
  frameGroupAttributes,
  aggregatePauseAttributes,
  aggregateLoudnessAttributes,
} = require('./frames');

const SIMILAR_TYPES = [TYPE_BLACKFRAMES, TYPE_MONOCHROMEFRAMES];

function _groupFramesToShots(frames, minFrameSimilarity = MINFRAMESIMILARITY) {
  const frameGroups = [];
  let curGroup = [];

  if (frames.length === 0) {
    return frameGroups;
  }

  curGroup.push(frames[0]);
  for (let i = 1; i < frames.length; i += 1) {
    const pre = curGroup[curGroup.length - 1];
    const cur = frames[i];

    // similarity could fail on transition color frames (black/monochrome), use the color properties
    const preColorProps = pre.colorProps || {};
    const curColorProps = cur.colorProps || {};

    // if already know it is BlackFrame, group the frames
    // cosim could fail with lower similarity (<0.6) even with two black frames
    if (preColorProps.isBlack && curColorProps.isBlack) {
      curGroup.push(cur);
      continue;
    }

    if (preColorProps.isBlack !== curColorProps.isBlack) {
      frameGroups.push(curGroup);
      curGroup = [cur];
      continue;
    }

    if (preColorProps.isMonochrome !== curColorProps.isMonochrome) {
      frameGroups.push(curGroup);
      curGroup = [cur];
      continue;
    }

    if (preColorProps.isMonochrome && preColorProps.dominantColorName !== curColorProps.dominantColorName) {
      frameGroups.push(curGroup);
      curGroup = [cur];
      continue;
    }

    const similarity = cosim(pre.embedding, cur.embedding);
    if (similarity < minFrameSimilarity) {
      frameGroups.push(curGroup);
      curGroup = [cur];
      continue;
    }

    curGroup.push(cur);
  }

  if (curGroup.length) {
    frameGroups.push(curGroup);
    curGroup = [];
  }

  const reduced = _reduceGroups(frameGroups);

  console.log(`GroupFramesToShots: Reduce groups from ${frameGroups.length} to ${reduced.length}`);

  return reduced;
}

function _reduceGroups(groups) {
  const reducedGroups = [];

  if (groups.length === 0) {
    return reducedGroups;
  }

  reducedGroups.push(groups[0]);
  for (let i = 1; i < groups.length; i += 1) {
    const preGroup = reducedGroups[reducedGroups.length - 1];
    const curGroup = groups[i];
    const nexGroup = groups[i + 1];

    if (curGroup.length > 1) {
      reducedGroups.push(curGroup);
      continue;
    }

    let preSimilarity = 0;
    let nexSimilarity = 0;

    const curFrame = curGroup[0];
    const embedding = curFrame.embedding;

    const preFrame = preGroup[preGroup.length - 1];
    if (preFrame.knownType === curFrame.knownType) {
      for (const frame of preGroup) {
        const sim = cosim(frame.embedding, embedding);
        preSimilarity = Math.max(sim, preSimilarity);
      }
    } else if (SIMILAR_TYPES.includes(preFrame.knownType) && SIMILAR_TYPES.includes(curFrame.knownType)) {
      const preColor = preFrame.colorProps.dominantColorName;
      const curColor = curFrame.colorProps.dominantColorName;
      if (preColor === curColor) {
        for (const frame of preGroup) {
          const sim = cosim(frame.embedding, embedding);
          preSimilarity = Math.max(sim, preSimilarity);
        }
      }
    }

    if (nexGroup) {
      const nexFrame = nexGroup[0];
      if (nexFrame.knownType === curFrame.knownType) {
        for (const frame of nexGroup) {
          const sim = cosim(embedding, frame.embedding);
          nexSimilarity = Math.max(sim, nexSimilarity);
        }
      } else if (SIMILAR_TYPES.includes(nexFrame.knownType) && SIMILAR_TYPES.includes(curFrame.knownType)) {
        const nexColor = nexFrame.colorProps.dominantColorName;
        const curColor = curFrame.colorProps.dominantColorName;
        if (nexColor === curColor) {
          for (const frame of nexGroup) {
            const sim = cosim(embedding, frame.embedding);
            nexSimilarity = Math.max(sim, nexSimilarity);
          }
        }
      }
    }

    if (preSimilarity < 0.72 && nexSimilarity < 0.72) {
      reducedGroups.push(curGroup);
      continue;
    }

    if (preSimilarity > nexSimilarity) {
      console.log(`Merge Shot#[${i}, ${i - 1}]: Frame# [${curFrame.frameNum}]: preSim = ${preSimilarity}, nexSim = ${nexSimilarity}`);
      preGroup.push(curFrame);
    } else {
      console.log(`Merge Shot#[${i}, ${i + 1}]: Frame# [${curFrame.frameNum}]: preSim = ${preSimilarity}, nexSim = ${nexSimilarity}`);
      nexGroup.unshift(curFrame);
    }
  }

  return reducedGroups;
}

function _verifyFramesAndShots(shotGroups) {
  shotGroups.sort((a, b) =>
    a.shot - b.shot);

  for (let i = 0; i < shotGroups.length; i += 1) {
    const cur = shotGroups[i];
    const nex = shotGroups[i + 1];

    if (nex === undefined) {
      continue;
    }

    if (!cur.frameSequences || !cur.frameSequences[0]) {
      throw new Error(`Missing frameSequences: Shot#${cur.shot}`);
    }

    if (cur.shot >= nex.shot) {
      throw new Error(`Incorrect shot order: Shot#${cur.shot} >= ${nex.shot}`);
    }

    if (cur.timestampRange[1] >= nex.timestampRange[0]) {
      throw new Error(`Incorrect shot timestamp: Shot#${cur.shot} [${toHHMMSS(cur.timestampRange[0], true)} - ${toHHMMSS(cur.timestampRange[1], true)}] >= Shot #${nex.shot} [${toHHMMSS(nex.timestampRange[0], true)} - ${toHHMMSS(nex.timestampRange[1], true)}]`);
    }

    if (cur.frameRange[1] >= nex.frameRange[0]) {
      throw new Error(`Incorrect shot frame range: Shot#${cur.shot} [${cur.frameRange[0]} - ${cur.frameRange[1]}] >= Shot #${nex.shot} [${nex.frameRange[0]} - ${cur.frameRange[1]}`);
    }
  }

  console.log(`Verify all frames and shots, ${shotGroups.length} shots.`);
}

function _shotGroupAttributes(shotId, shotGroup) {
  const attribute = frameGroupAttributes(shotGroup);

  return {
    shot: shotId,
    ...attribute,
  };
}

function _tagAudioMetadataToShots(frameMap, shotGroup) {
  if ((shotGroup || []).length === 0) {
    return shotGroup;
  }

  for (const shot of shotGroup) {
    const { frameRange: [fmin, fmax] } = shot;

    const frames = [];

    for (let i = fmin; i <= fmax; i += 1) {
      const frame = frameMap[String(i)];
      if (frame === undefined) {
        continue;
      }
      frames.push(frame);
    }

    let attribute = aggregatePauseAttributes(frames);
    if (attribute.length > 0) {
      const [pauseInDialogue, pauseDuration] = attribute;
      shot.pauseInDialogue = pauseInDialogue;
      shot.pauseDuration = pauseDuration;
    }

    attribute = aggregateLoudnessAttributes(frames);
    if (attribute.length > 0) {
      const [loudnessLevel] = attribute;
      shot.loudnessLevel = loudnessLevel;
    }
  }

  return shotGroup;
}

////////////////////////////////////////////////////
// Functions to export
////////////////////////////////////////////////////
function groupFramesToShots(frames, minFrameSimilarity) {
  return _groupFramesToShots(frames, minFrameSimilarity);
}

function verifyFramesAndShots(shotGroups) {
  return _verifyFramesAndShots(shotGroups);
}

function shotGroupAttributes(shotId, shotGroup) {
  return _shotGroupAttributes(shotId, shotGroup);
}

function tagAudioMetadataToShots(frameMap, shotGroup) {
  return _tagAudioMetadataToShots(frameMap, shotGroup);
}

module.exports = {
  groupFramesToShots,
  shotGroupAttributes,
  verifyFramesAndShots,
  tagAudioMetadataToShots,
};
