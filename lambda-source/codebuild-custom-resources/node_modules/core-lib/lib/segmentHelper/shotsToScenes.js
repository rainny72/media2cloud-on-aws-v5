// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const {
  cosim,
} = require('../simpleMath');
const {
  TYPE_BLACKFRAMES,
  TYPE_MONOCHROMEFRAMES,
  MINFRAMESIMILARITY,
  MAXTIMEDISTANCE,
  TAG_ABSOLUTESILENT,
  TAG_VERYQUIET,
} = require('./definitions');
const {
  shotGroupAttributes,
} = require('./framesToShots');

const SIMILAR_TYPES = [TYPE_BLACKFRAMES, TYPE_MONOCHROMEFRAMES];

function _groupShotsToScenes(
  frames,
  shots,
  similarity,
  minFrameSimilarity = MINFRAMESIMILARITY,
  maxTimeDistance = MAXTIMEDISTANCE
) {
  const frameMap = {};
  const shotMap = {};

  // create shot mapping
  for (const shot of shots) {
    shotMap[String(shot.shot)] = shot;
  }

  // create frame mapping
  for (const frame of frames) {
    const frameId = String(frame.frameNum);
    frameMap[frameId] = frame;

    const shotId = String(frame.shot);
    if (shotMap[shotId] === undefined) {
      throw new Error(`frame shots of #${shotId} is null`);
    }
    if (shotMap[shotId].frames === undefined) {
      shotMap[shotId].frames = [];
    }
    shotMap[shotId].frames.push(frame);
  }

  // adding similar shots to the frame mapping
  for (const item of similarity) {
    const frameId = String(item.frameNum);
    if (frameMap[frameId] === undefined) {
      throw new Error(`Frame#${frameId} not found in frameMap`);
    }
    frameMap[frameId].simShots = _findSimShots(frameMap, item, minFrameSimilarity);
  }

  // divide shots into pre-defined/known types
  const groupByPredefinedTypes = _groupByPredefinedTypes(shots);

  // for each divided group, collect the similar shots, apply the lower/upper bound
  for (const subGroup of groupByPredefinedTypes) {
    const shotIds = subGroup.map((shot) => shot.shot);
    const lowerBound = Math.min(...shotIds);
    const upperBound = Math.max(...shotIds);

    // collect all related shots
    for (const curShot of subGroup) {
      const relatedShots = _findRelatedShots(curShot, shotMap, [lowerBound, upperBound], maxTimeDistance);
      curShot.relatedShots = relatedShots;
    }
  }

  // generate a list of related shots from the shots
  const listOfRelatedShots = [];
  for (const curShot of Object.values(shots)) {
    const min = Math.min(...curShot.relatedShots);
    const max = Math.max(...curShot.relatedShots);
    listOfRelatedShots.push([min, max]);
  }

  listOfRelatedShots.sort((a, b) => {
    if (a[0] < b[0]) {
      return -1;
    }
    if (a[0] > b[0]) {
      return 1;
    }
    return b[1] - a[1];
  });

  // merge overlapped shots
  let stack = [];
  stack.push(listOfRelatedShots[0]);

  for (let i = 1; i < listOfRelatedShots.length; i += 1) {
    const pre = stack[stack.length - 1];
    const cur = listOfRelatedShots[i];
    if (cur[0] > pre[1]) {
      stack.push(cur);
      continue;
    }
    const ids = pre.concat(cur);
    const min = Math.min(...ids);
    const max = Math.max(...ids);

    stack.pop();
    stack.push([min, max]);
  }
  console.log(`[1st Pass]: Shots to scenes: ${Object.values(shotMap).length} -> ${stack.length}`);

  const shotsToScenes = _breakScenesByAudioMetadata(shotMap, stack);
  console.log(`[2nd Pass]: Scenes w/audio metadata: ${stack.length} -> ${shotsToScenes.length}`);

  // Finally, add the scene id
  const finalized = [];

  for (let i = 0; i < shotsToScenes.length; i += 1) {
    const shots = shotsToScenes[i];
    shots.sort((a, b) => a.shot - b.shot);

    const timestampRange = [
      shots[0].timestampRange[0],
      shots[shots.length - 1].timestampRange[1],
    ];
    const frameRange = [
      shots[0].frameRange[0],
      shots[shots.length - 1].frameRange[1],
    ];
    const shotRange = [
      shots[0].shot,
      shots[shots.length - 1].shot,
    ];

    for (const shot of shots) {
      for (const frame of shot.frames) {
        frame.scene = i;
      }
    }

    // promote the first shot metadata to scene
    const {
      knownType,
      loudnessLevel,
      pauseInDialogue,
      pauseDuration,
    } = shots[0];

    finalized.push({
      scene: i,
      timestampRange,
      frameRange,
      shotRange,
      knownType,
      loudnessLevel,
      pauseInDialogue,
      pauseDuration,
      shots,
    });
  }

  return finalized;
}

function _findRelatedShots(curShot, shotMap, boundRange, maxTimeDistance = MAXTIMEDISTANCE) {
  const [lowerBound, upperBound] = boundRange;

  let prevShots = [];
  let nextShots = [];

  for (const frame of curShot.frames) {
    const {
      simShots,
    } = frame;

    for (const simShot of simShots) {
      if (simShot < curShot.shot) {
        prevShots.push(simShot);
      } else if (simShot > curShot.shot) {
        nextShots.push(simShot);
      }
    }
  }

  prevShots = [...new Set(prevShots)]
    .sort((a, b) =>
      a - b);

  nextShots = [...new Set(nextShots)]
    .sort((a, b) =>
      a - b);

  // collect related shots
  let relatedShots = [];

  // walk backward
  // let firstTimestamp = curShot.frames[0].timestampMillis;
  let firstTimestamp = curShot.timestampRange[0];
  for (const id of prevShots) {
    const prevShot = shotMap[String(id)];

    // const timestamp = prevShot.frames[prevShot.frames.length - 1].timestampMillis;
    const timestamp = prevShot.timestampRange[1];
    if (Math.abs(timestamp - firstTimestamp) > maxTimeDistance) {
      break;
    }
    relatedShots.push(id);
    // firstTimestamp = prevShot.frames[0].timestampMillis;
    firstTimestamp = prevShot.timestampRange[0];
  }

  // walk forward
  // let lastTimestamp = curShot.frames[curShot.frames.length - 1].timestampMillis;
  let lastTimestamp = curShot.timestampRange[1];
  for (const id of nextShots) {
    const nextShot = shotMap[String(id)];

    // const timestamp = nextShot.frames[0].timestampMillis;
    const timestamp = nextShot.timestampRange[0];
    if (Math.abs(timestamp - lastTimestamp) > maxTimeDistance) {
      break;
    }
    relatedShots.push(id);
    // lastTimestamp = nextShot.frames[nextShot.frames.length - 1].timestampMillis;
    lastTimestamp = nextShot.timestampRange[1];
  }

  // make sure the related shots are within the allowed range
  relatedShots = [...new Set(relatedShots), curShot.shot]
    .filter((x) =>
      x >= lowerBound && x <= upperBound);

  relatedShots.sort((a, b) => a - b);

  return relatedShots;
}

function _groupByPredefinedTypes(shots) {
  const groups = [];
  let curGroup = [shots[0]];

  for (let i = 1; i < shots.length; i += 1) {
    const pre = curGroup[curGroup.length - 1];
    const cur = shots[i];

    if (pre.knownType === cur.knownType) {
      curGroup.push(cur);
      continue;
    }

    if (SIMILAR_TYPES.includes(pre.knownType) && SIMILAR_TYPES.includes(cur.knownType)) {
      const preFrame = pre.frames[pre.frames.length - 1];
      const curFrame = cur.frames[0];
      const preColor = (preFrame.colorProps || {}).dominantColorName;
      const curColor = (curFrame.colorProps || {}).dominantColorName;

      if (preColor === curColor) {
        curGroup.push(cur);
        continue;
      }
    }

    groups.push(curGroup);
    curGroup = [cur];
  }

  if (curGroup.length > 0) {
    groups.push(curGroup);
    curGroup = [];
  }

  return groups;
}

function _findSimShots(frameMap, item, minFrameSimilarity) {
  const {
    similar_frames: simFrames,
  } = item;

  // collect similar shots
  let simShots = [];
  for (const { frameNum, D } of simFrames) {
    if (D < minFrameSimilarity) {
      continue;
    }
    simShots.push(frameMap[String(frameNum)].shot);
  }
  simShots = [...new Set(simShots)];

  return simShots;
}

function _sceneGroupAttributes(sceneId, shotsInScene) {
  let shotGroups = shotsInScene;

  // nested arrays of scene -> shots -> frames
  if (Array.isArray(shotsInScene[0]) && shotsInScene[0][0].embedding) {
    shotGroups = [];
    for (const shotGroup of shotsInScene) {
      const shotId = shotGroup[0].shot;
      const attribute = shotGroupAttributes(shotId, shotGroup);
      shotGroups.push(attribute);
    }
  }

  shotGroups.sort((a, b) => a.shot - b.shot);

  const firstShot = shotGroups[0];
  const lastShot = shotGroups[shotGroups.length - 1];

  const shotRange = [firstShot.shot, lastShot.shot];
  const frameRange = [firstShot.frameRange[0], lastShot.frameRange[1]];
  const timestampRange = [firstShot.timestampRange[0], lastShot.timestampRange[1]];
  const smpteTimecodes = [firstShot.smpteTimecodes[0], lastShot.smpteTimecodes[1]];

  const {
    knownType,
    loudnessLevel,
    pauseInDialogue,
    pauseDuration,
  } = firstShot;

  const attribute = {
    scene: sceneId,
    knownType,
    loudnessLevel,
    pauseInDialogue,
    pauseDuration,
    shotRange,
    frameRange,
    timestampRange,
    smpteTimecodes,
    shots: shotGroups,
  };

  return attribute;
}

function _verifyShotsAndScenes(sceneGroups) {
  sceneGroups;
  return;
}

function _breakScenesByAudioMetadata(shotMap, shotRanges) {
  const loudnessTags = [TAG_ABSOLUTESILENT, TAG_VERYQUIET];
  const shotsToScenes = [];

  for (const [min, max] of shotRanges) {
    if (min === max) {
      const shot = shotMap[String(min)];
      if (shot === undefined) {
        throw new Error(`Shot#${shot} not found`);
      }
      shotsToScenes.push([shot]);
      continue;
    }

    const shots = [];
    for (let i = min; i <= max; i += 1) {
      const shot = shotMap[String(i)];
      if (shot === undefined) {
        throw new Error(`Shot#${shot} not found`);
      }
      shots.push(shot);
    }

    let curGroup = [shots[0]];

    for (let i = 1; i < shots.length; i += 1) {
      const pre = curGroup[curGroup.length - 1];
      const cur = shots[i];

      const {
        timestampRange: [pmin, pmax],
      } = pre;
      const {
        timestampRange: [cmin, cmax],
      } = cur;

      // if loudness level switches or transition to dialogue pause
      // and both shot are longer than 1000ms
      // and similarity is lower than 0.60
      // then breaks the scene
      const preSilent = loudnessTags.includes(pre.loudnessLevel);
      const curSilent = loudnessTags.includes(cur.loudnessLevel);
      const prePause = pre.pauseInDialogue;
      const curPause = cur.pauseInDialogue;

      if ((preSilent !== curSilent) || (curPause && !prePause)) {
        if ((pmax - pmin) > 1000 && (cmax - cmin) > 1000) {
          const preFrame = pre.frames[pre.frames.length - 1];
          const curFrame = cur.frames[0];
          const sim = cosim(preFrame.embedding, curFrame.embedding);
          if (sim < 0.60) {
            shotsToScenes.push(curGroup);
            curGroup = [cur];
            continue;
          }
        }
      }

      curGroup.push(cur);
    }

    if (curGroup.length > 0) {
      shotsToScenes.push(curGroup);
      curGroup = [];
    }
  }

  return shotsToScenes;
}

////////////////////////////////////////////////////
// Functions to export
////////////////////////////////////////////////////
function groupShotsToScenes(frames, shots, similarity, minFrameSimilarity, maxTimeDistance) {
  return _groupShotsToScenes(frames, shots, similarity, minFrameSimilarity, maxTimeDistance);
}

function sceneGroupAttributes(sceneId, shotsInScene) {
  return _sceneGroupAttributes(sceneId, shotsInScene);
}

function verifyShotsAndScenes(sceneGroups) {
  return _verifyShotsAndScenes(sceneGroups);
}

module.exports = {
  groupShotsToScenes,
  sceneGroupAttributes,
  verifyShotsAndScenes,
};
