// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

class SimpleMath {
  static cosim(a, b) {
    return _cosim(a, b);
  }

  static cosdist(a, b) {
    return 1 - (_cosim(a, b) + 1) / 2;
  }

  static min(arr) {
    let minValue = Number.MAX_SAFE_INTEGER;
    try {
      for (const num of arr) {
        if (!Number.isNaN(num)) {
          minValue = Math.min(minValue, num);
        }
      }
      return minValue;
    } catch (e) {
      e;
      return minValue;
    }
  }

  static max(arr) {
    let maxValue = Number.MIN_SAFE_INTEGER;
    try {
      for (const num of arr) {
        if (!Number.isNaN(num)) {
          maxValue = Math.max(maxValue, num);
        }
      }
      return maxValue;
    } catch (e) {
      e;
      return maxValue;
    }
  }

  static rms(arr) {
    try {
      let len = 0;
      let squareSum = 0;

      for (const num of arr) {
        if (!Number.isNaN(num)) {
          squareSum += (num ** 2);
          len += 1;
        }
      }

      return (squareSum / len) ** 0.5;
    } catch (e) {
      e;
      return 0;
    }
  }

  // normalized RMS
  static normalizedRMS(arr) {
    try {
      const filtered = _filterNaN(arr);

      let mean = 0;
      let sum = 0;

      for (let i = 0; i < filtered.length; i += 1) {
        let val = filtered[i];
        sum += Math.abs(val);
        mean += val ** 2;
      }

      mean = (mean * filtered.length) ** 0.5;

      if (mean === 0) {
        return 0;
      }

      return sum / mean;
    } catch (e) {
      e;
      return 0;
    }
  }

  static mean(arr) {
    return _arithmeticMean(arr);
  }

  static arithmeticMean(arr) {
    return _arithmeticMean(arr);
  }

  static harmonicMean(arr) {
    try {
      const filtered = _filterNaN(arr);
      const reciprocals = filtered.reduce((a, b) => {
        if (b === 0) {
          return a;
        }
        return a + (1 / b);
      }, 0);

      if (reciprocals === 0) {
        return 0;
      }

      return filtered.length / reciprocals;
    } catch (e) {
      e;
      return 0;
    }
  }

  static geometricMean(arr) {
    try {
      const filtered = _filterNaN(arr);
      const products = filtered.reduce((a, b) => {
        if (b === 0) {
          return a;
        }
        return a * b;
      }, 1);

      return products ** (1 / filtered.length);
    } catch (e) {
      e;
      return 0;
    }
  }

  static stddev(arr) {
    try {
      const filtered = _filterNaN(arr);
      const mean = _arithmeticMean(filtered);

      const sqrtDiff = filtered
        .map((val) =>
          (val - mean) ** 2);

      const variance = sqrtDiff
        .reduce((acc, val) =>
          acc + val, 0) / filtered.length;

      return variance ** 0.5;
    } catch (e) {
      e;
      return 0;
    }
  }

  static median(arr) {
    try {
      const filtered = _filterNaN(arr);
      filtered.sort((a, b) => a - b);

      const idx = filtered.length / 2;
      return (filtered[Math.floor(idx)] + filtered[Math.ceil(idx)]) / 2;
    } catch (e) {
      e;
      return 0;
    }
  }

  static quartile(arr, q) {
    try {
      const filtered = _filterNaN(arr);
      filtered.sort((a, b) => a - b);

      const pos = (filtered.length - 1) * q;
      const base = Math.floor(pos);
      const remainder = pos - base;

      if (remainder === 0) {
        return filtered[base];
      }

      return filtered[base] + remainder * (filtered[base + 1] - filtered[base]);
    } catch (e) {
      e;
      return 0;
    }
  }

  // same as minkowski w/ p = 1
  static manhattan(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
      throw new Error('manhattan requires two arrays');
    }

    const size = Math.min(a.length, b.length);

    let distance = 0.0;
    for (let i = 0; i < size; i += 1) {
      distance += Math.abs(a[i] - b[i]);
    }

    return distance;
  }

  // minkowski w/ p = 2
  static euclidean(a, b) {
    return _minkowski(a, b, 2);
  }

  static minkowski(a, b, p) {
    return _minkowski(a, b, p);
  }

  static centroid(a) {
    return _centroid(a);
  }

  static normalize(a) {
    return _normalize(a);
  }
}

function _filterNaN(arr) {
  if (!Array.isArray(arr)) {
    throw new Error('not an array');
  }

  const filtered = arr.filter((x) =>
    !Number.isNaN(x));

  if (filtered.length === 0) {
    throw new Error('array not contain any valid number');
  }

  return filtered;
}

function _cosim(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    return 0;
  }

  let meanA = 0;
  let meanB = 0;
  let dotProduct = 0;

  // dot product, use the least dimension
  const length = Math.min(a.length, b.length);

  for (let i = 0; i < length; i += 1) {
    dotProduct += a[i] * b[i];
    meanA += a[i] ** 2;
    meanB += b[i] ** 2;
  }

  // compute the remaining
  if (a.length > b.length) {
    for (let i = length; i < a.length; i += 1) {
      meanA += a[i] ** 2;
    }
  } else if (b.length > a.length) {
    for (let i = length; i < b.length; i += 1) {
      meanB += b[i] ** 2;
    }
  }

  meanA **= 0.5;
  meanB **= 0.5;

  if ((meanA * meanB) === 0) {
    return 0;
  }

  return dotProduct / (meanA * meanB);
}

function _arithmeticMean(arr) {
  try {
    const filtered = _filterNaN(arr);
    const mean = filtered
      .reduce((acc, val) =>
        acc + val, 0) / filtered.length;

    return mean;
  } catch (e) {
    e;
    return 0;
  }
}

function _minkowski(a, b, p = 3) {
  if (!Array.isArray(a) || !Array.isArray(b)) {
    throw new Error(`minkowski with p=${p} requires two arrays`);
  }

  const size = Math.min(a.length, b.length);

  let distance = 0.0;
  for (let i = 0; i < size; i += 1) {
    distance += Math.abs(a[i] - b[i]) ** p;
  }

  distance = distance ** (1 / p);

  return distance;
}

function _centroid(data) {
  if (!Array.isArray(data) || !Array.isArray(data[0])) {
    throw new Error(`centroid requires a list of embeddings`);
  }

  const dimension = data[0].length;
  const centroid = new Array(dimension).fill(0);

  for (const embed of data) {
    if (!Array.isArray(embed) || embed.length !== dimension) {
      throw new Error(`centroid requires a list of same size embeddings`);
    }
    for (let i = 0; i < dimension; i += 1) {
      centroid[i] += embed[i]
    }
  }

  for (let i = 0; i < dimension; i += 1) {
    centroid[i] /= data.length;
  }

  return centroid;
}

function _normalize(data) {
  if (!Array.isArray(data) || !Array.isArray(data[0])) {
    throw new Error(`normalize requires a list of embeddings`);
  }

  const normalized = [];
  for (const item of data) {
    let norm = 0;
    for (const x of item) {
      norm += (x ** 2);
    }
    norm = norm ** 0.5;

    if (norm <= 0) {
      normalized.push(item.slice());
    } else {
      const vector = [];
      for (const x of item) {
        vector.push(x / norm);
      }
      normalized.push(vector);
    }
  }

  return normalized;
}

module.exports = SimpleMath;
