"use strict";
// Copyright (c) 2019-2019 The Authors.
// SPDX-License-Identifier: BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
// (node:23174) MaxListenersExceededWarning: Possible EventEmitter memory
// leak detected. 11 uncaughtException listeners added to [process]. Use
// emitter.setMaxListeners() to increase limit
// process.setMaxListeners(0);
var moduleOptions = {
    // This can be used to override the way the wasm file is located in
    // the file system when it is not located just besides the js script.
    locateFile: function (path, scriptDirectory) {
        return scriptDirectory + path;
    },
};
describe('Raw binding to libmagic unit tests', function () {
    var bindingModule;
    beforeAll(function (done) {
        bindingModule = require('@npcz/magic/dist/magic-js');
        bindingModule(moduleOptions).then(function (binding) {
            expect(binding).not.toBeNull();
            expect(binding.MagicBinding).not.toBeNull();
            done();
        });
    });
    it('exports libmagic flags', function (done) {
        bindingModule().then(function (binding) {
            expect(binding).not.toBeNull();
            var props = Object.getOwnPropertyNames(binding);
            expect(props.includes('MAGIC_NONE'));
            expect(props.includes('MAGIC_DEBUG'));
            expect(props.includes('MAGIC_SYMLINK'));
            expect(props.includes('MAGIC_COMPRESS'));
            expect(props.includes('MAGIC_DEVICES'));
            expect(props.includes('MAGIC_MIME_TYPE'));
            expect(props.includes('MAGIC_CONTINUE'));
            expect(props.includes('MAGIC_CHECK'));
            expect(props.includes('MAGIC_PRESERVE_ATIME'));
            expect(props.includes('MAGIC_RAW'));
            expect(props.includes('MAGIC_ERROR'));
            expect(props.includes('MAGIC_MIME_ENCODING'));
            expect(props.includes('MAGIC_MIME_ENCODING)'));
            expect(props.includes('MAGIC_APPLE'));
            expect(props.includes('MAGIC_EXTENSION'));
            expect(props.includes('MAGIC_COMPRESS_TRANSP'));
            expect(props.includes('MAGIC_APPLE)'));
            expect(props.includes('MAGIC_NO_CHECK_COMPRESS'));
            expect(props.includes('MAGIC_NO_CHECK_TAR'));
            expect(props.includes('MAGIC_NO_CHECK_SOFT'));
            expect(props.includes('MAGIC_NO_CHECK_APPTYPE'));
            expect(props.includes('MAGIC_NO_CHECK_ELF'));
            expect(props.includes('MAGIC_NO_CHECK_TEXT'));
            expect(props.includes('MAGIC_NO_CHECK_CDF'));
            expect(props.includes('MAGIC_NO_CHECK_CSV'));
            expect(props.includes('MAGIC_NO_CHECK_TOKENS'));
            expect(props.includes('MAGIC_NO_CHECK_ENCODING'));
            expect(props.includes('MAGIC_NO_CHECK_JSON'));
            expect(props.includes('MAGIC_NO_CHECK_BUILTIN'));
            done();
        });
    });
    it('implements static version()', function (done) {
        bindingModule().then(function (binding) {
            var version = binding.MagicBinding.version();
            // We're at least using libmagic 5.x
            expect(version).toBeGreaterThan(500);
            done();
        });
    });
    it('implements static defaultPath()', function (done) {
        bindingModule().then(function (binding) {
            var path = binding.MagicBinding.defaultPath();
            expect(path).not.toBeNull();
            done();
        });
    });
    it('can be successfully initialized with a magic.mgc path and specific flags', function (done) {
        bindingModule().then(function (binding) {
            var result = binding.MagicBinding.init(require.resolve('@npcz/magic/dist/magic.mgc'), binding.MAGIC_DEBUG);
            expect(result).not.toEqual(-1);
            expect(binding.MagicBinding.flags()).toEqual(binding.MAGIC_DEBUG);
            done();
        });
    });
    it('init fails with return val -1 if path does not point to magic.mgc', function (done) {
        bindingModule().then(function (binding) {
            var result = binding.MagicBinding.init(path.normalize(path.join(__dirname, '..', 'dist', 'NOT_magic.mgc')), binding.MAGIC_DEBUG);
            expect(result).toEqual(-1);
            done();
        });
    });
    it('can not do detection before init is called', function (done) {
        bindingModule().then(function (binding) {
            var magic = new binding.MagicBinding();
            var result = magic.detect('fffff', -1);
            expect(result.startsWith('ERROR: ')).toBeTruthy();
            done();
        });
    });
    it('does the magic detection', function (done) {
        bindingModule().then(function (binding) {
            var magicPath = require.resolve('@npcz/magic/dist/magic.mgc');
            var initResult = binding.MagicBinding.init(magicPath, binding.MAGIC_NONE);
            expect(initResult).not.toEqual(-1);
            var magic = new binding.MagicBinding();
            var result = magic.detect(magicPath, -1);
            expect(result.startsWith('magic binary file for file(1) cmd')).toBeTruthy();
            result = magic.detect(magicPath, binding.MAGIC_MIME);
            expect(result).toEqual('application/x-file; charset=binary');
            done();
        });
    });
});
//# sourceMappingURL=binding.spec.js.map