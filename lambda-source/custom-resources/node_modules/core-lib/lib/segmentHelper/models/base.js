// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const {
  BedrockRuntimeClient,
  InvokeModelCommand,
  ConverseCommand,
  ValidationException,
} = require('@aws-sdk/client-bedrock-runtime');
const {
  Solution: {
    Metrics: { CustomUserAgent },
  },
} = require('../../environment');
const {
  pause,
  shorten,
  debugLocally,
} = require('../../commonUtils');
const {
  retryableExceptions,
} = require('../../exceptionHelper');
const xraysdkHelper = require('../../xraysdkHelper');
const retryStrategyHelper = require('../../retryStrategyHelper');
const {
  parseModelOutputContent,
} = require('./outputParser');

const ExpectedBucketOwner = process.env.ENV_EXPECTED_BUCKET_OWNER;
const MIME_JSON = 'application/json';

let _bedrockRuntimeClient;

class BaseModel {
  constructor(config = {}) {
    this.$config = config;
    this.$modelParams = {};
    this.$inferenceConfig = {
      // maxTokens: 5120,
      // temperature: 0.7,
      // topP: 0.9,
      // stopSequences: [],
    };
  }

  static canSupport(modelString) {
    modelString;
    return false;
  }

  get config() {
    return this.$config;
  }

  get modelRegion() {
    return this.config.modelRegion;
  }

  get modelId() {
    return this.config.modelId;
  }

  get modelName() {
    return this.config.modelName;
  }

  get modelVersion() {
    return this.config.modelVersion;
  }

  get modelType() {
    return this.config.modelType;
  }

  get modelPricing() {
    return this.config.modelPricing;
  }

  get modelParams() {
    return this.$modelParams;
  }

  get inferenceConfig() {
    return this.$inferenceConfig;
  }

  get supportedRegions() {
    return this.config.supportedRegions || [];
  }

  canDo(text = '') {
    return this.modelType.includes(text);
  }

  async inference(system, inputs = [], preferredRegion = '', maxRetries = 2) {
    if (inputs.length === 0) {
      throw new Error('input not specified');
    }

    const params = {
      modelId: this.modelId,
      inferenceConfig: this.inferenceConfig,
      messages: [],
    };

    if (system !== undefined && system.length > 0) {
      params.system = [{ text: system }];
    }

    const content = [];
    for (const input of inputs) {
      for (const [key, value] of Object.entries(input)) {
        if (!value) {
          console.log(`input ${key} not defined`);
          continue;
        }
        if (key === 'text') {
          content.push({ text: value });
          continue;
        }
        if (key === 'image') {
          content.push({
            image: { format: 'jpeg', source: { bytes: value } },
          });
          continue;
        }
        if (key === 'video') {
          content.push({
            video: {
              format: 'mp4',
              source: { s3Location: { uri: value, bucketOwner: ExpectedBucketOwner } },
            },
          });
        }
      }
    }
    params.messages = [{ role: 'user', content }];

    return await this.converse(params, preferredRegion, maxRetries);
  }

  async converse(params, preferredRegion = '', maxRetries = 2) {
    const t0 = Date.now();

    let modelRegion = this.modelRegion;
    if (preferredRegion.length > 0) {
      modelRegion = preferredRegion;
    }

    const runtimeClient = await _getBedrockRuntimeClient(modelRegion);
    let response = await _converseRetry(runtimeClient, params, maxRetries);
    const {
      metrics: { latencyMs },
      stopReason,
      usage,
      output: { message: { content: contentOutput = [] } },
    } = response;

    // estimate the token cost
    const { inputPerTokenCost, outputPerTokenCost } = this.modelPricing;
    const { inputTokens, outputTokens } = usage;
    usage.estimatedCost = inputTokens * inputPerTokenCost + outputTokens * outputPerTokenCost;

    // remove image bytes and shorten text
    const { content: contents } = params.messages[0];
    for (const content of contents) {
      if (content.image) {
        const { image: { source } } = content;
        source.bytes = '[Image]';
      } else if (content.text) {
        content.text = shorten(content.text, 1024);
      }
    }

    let jsonOutput;

    // https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html#API_runtime_Converse_ResponseElements
    // end_turn | tool_use | max_tokens | stop_sequence | guardrail_intervened | content_filtered
    if (stopReason !== 'end_turn') {
      jsonOutput = {
        stopReason,
        [stopReason]: (contentOutput[0] || {}).text,
      };
    } else {
      // parse the output json
      if ((contentOutput[0] || {}).text !== undefined) {
        jsonOutput = parseModelOutputContent(contentOutput[0].text);
      }
    }

    let inferenceTime = Date.now() - t0;
    if (latencyMs) {
      inferenceTime = latencyMs;
    }

    // return both request and response
    return {
      request: params,
      response: { usage, stopReason, jsonOutput, inferenceTime, modelId: this.modelId },
    };
  }

  async invokeEndpoint(param, preferredRegion = '') {
    const t0 = Date.now();

    let modelRegion = this.modelRegion;
    if (preferredRegion.length > 0) {
      modelRegion = preferredRegion;
    }

    const runtimeClient = await _getBedrockRuntimeClient(modelRegion);

    const params = {
      modelId: this.modelId,
      contentType: MIME_JSON,
      accept: MIME_JSON,
      body: JSON.stringify(param),
    };

    let response = await _invokeEndpointRetry(runtimeClient, params);
    if (response instanceof Error) {
      throw response;
    }

    if ((response || {}).body === undefined) {
      throw new Error('No response!');
    }

    response = new TextDecoder().decode(response.body);
    response = JSON.parse(response);

    response.modelId = this.modelId;
    response.inferenceTime = Date.now() - t0;

    return response;
  }
}

async function _getBedrockRuntimeClient(region) {
  if (_bedrockRuntimeClient === undefined
    || (await _bedrockRuntimeClient.config.region()) !== region
  ) {
    _bedrockRuntimeClient = xraysdkHelper(new BedrockRuntimeClient({
      region,
      customUserAgent: CustomUserAgent,
      retryStrategy: retryStrategyHelper(4),
    }));
  }
  return _bedrockRuntimeClient;
}

async function _converseRetry(runtimeClient, params, maxRetries = 2) {
  let response;
  let retries = 0;
  const accumulatedUsage = { inputTokens: 0, outputTokens: 0 };

  do {
    try {
      const command = new ConverseCommand(params);
      response = await runtimeClient.send(command);

      const {
        stopReason, usage: { inputTokens, outputTokens },
      } = response;
      accumulatedUsage.inputTokens += inputTokens;
      accumulatedUsage.outputTokens += outputTokens;

      // retry on max_tokens stop reason
      if (stopReason === 'max_tokens') {
        console.log(`[ERR]: ConverseCommand: stopReasons = ${stopReason}. RETRY AGAIN...(${retries}/${maxRetries})`);
        // exceed the maximum retries, stop retrying
        if (retries >= maxRetries) {
          throw new ValidationException();
        }
        // remove temperature/topP before retry
        retries += 1;
        response = undefined;
        delete params.inferenceConfig.topP;
        delete params.inferenceConfig.temperature;
        await pause(2000);
      } else {
        response.usage = accumulatedUsage;
        return response;
      }
    } catch (e) {
      const payloadSize = Buffer.byteLength(JSON.stringify(params));
      console.log(`[ERR]: ConverseCommand: ${e.name} - ${e.message} (payload = ${payloadSize})`);
      if (!debugLocally() || !retryableExceptions(e)) {
        throw e;
      }
      await pause(60000);
    }
  } while (response === undefined);
}

async function _invokeEndpointRetry(runtimeClient, params) {
  let response;
  do {
    try {
      const command = new InvokeModelCommand(params);
      response = await runtimeClient.send(command);
      return response;
    } catch (e) {
      const payloadSize = Buffer.byteLength(params.body);
      console.log(`[ERR]: InvokeModelCommand: ${e.name} - ${e.message} (payload = ${payloadSize})`);
      if (!debugLocally() || !retryableExceptions(e)) {
        throw e;
      }
      await pause(60000);
    }
  } while (response === undefined);
}

module.exports = BaseModel;
