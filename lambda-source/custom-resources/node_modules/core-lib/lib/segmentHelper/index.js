// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const {
  parse,
  join,
} = require('node:path');
const {
  createReadStream,
} = require('node:fs');
const {
  readdir,
} = require('node:fs/promises');
const {
  createTempDir,
  removeTempDir,
  extractFrames,
} = require('../ffmpegHelper');
const {
  isDropFrame,
  framerateToEnum,
  fromTimecode,
  toTimecode,
} = require('../timecodeUtils');
const {
  uploadStream,
} = require('../commonUtils');
const {
  loadModelConfigs,
  getPreferredModel,
} = require('./modelFactory');
const {
  groupFramesToShots,
  shotGroupAttributes,
  verifyFramesAndShots,
  tagAudioMetadataToShots,
} = require('./framesToShots');
const {
  groupShotsToScenes,
  sceneGroupAttributes,
  verifyShotsAndScenes,
} = require('./shotsToScenes');
const {
  createSequenceImage,
  computeFrameProperties,
  frameGroupAttributes,
  tagAudioMetadataToFrames,
} = require('./frames');
const {
  agnesClusterFramesToScenes,
} = require('./agnesClustering');
const CompositionPlaylist = require('./smpteST2067');
const DEFINITIONS = require('./definitions');

const {
  INFERENCE_CONCURRENCY,
} = DEFINITIONS;

async function _analyzeFrameBoundary(options, boundary, maxFrames) {
  let tmpDir;

  try {
    tmpDir = await createTempDir();
    console.log(`tmpDir = ${tmpDir}`);

    const {
      ffOptions: { url, ss, to, vf },
      filterSettings,
      inferenceConcurrency = INFERENCE_CONCURRENCY,
    } = options;

    let outputName = '%07d.jpg';
    const output = join(tmpDir, outputName);

    const t0 = Date.now();
    let cmdOpts = _makeFFmpegCommand(url, ss, to, vf, output, 3000);
    await extractFrames(cmdOpts);
    const t1 = Date.now();
    console.log(`extractFrames: elapsed = ${t1 - t0}ms`);

    let localFiles = await _fetchLocalFiles(tmpDir, maxFrames);

    // This could mean that the content is encoded with open GOP and
    // ffmpeg seek fails to find the first keyframe. Try with different
    // ss, to settings.
    if (localFiles.length === 0) {
      console.log('FAILED TO EXTRACT FRAME. TRY LARGER SEEK VALUE: 7s');

      const t0 = Date.now();
      cmdOpts = _makeFFmpegCommand(url, ss, to, vf, output, 7000);
      await extractFrames(cmdOpts);
      const t1 = Date.now();

      console.log(`extractFrames: elapsed = ${t1 - t0}ms`);

      localFiles = await _fetchLocalFiles(tmpDir, maxFrames);
    }

    // compute frame embedding and properties
    const frames = [];

    let promises = [];
    let lastException;

    let titanApiCount = 0;
    for (const localFile of localFiles) {
      if (promises.length >= inferenceConcurrency) {
        lastException = await _waitAndCheckExceptions(promises);
        promises = [];
      }

      if (lastException) {
        throw lastException;
      }

      const [frameFrom,] = boundary;
      const frameNum = (Number(localFile.frameNum) - 1) + frameFrom.frameNum;

      promises.push(computeFrameProperties(join(tmpDir, localFile.file), filterSettings)
        .then((res) => {
          titanApiCount += 1;
          frames.push({
            frameNum,
            file: localFile.file,
            ...res,
          });
        })
        .catch((e) => {
          return e;
        }));
    }

    if (promises.length > 0) {
      lastException = await _waitAndCheckExceptions(promises);
      if (lastException !== undefined) {
        throw lastException;
      }
    }

    // Now find new frames
    const newFrames = await _findNewFrames(tmpDir, frames, options);

    return { newFrames, titanApiCount };
  } catch (e) {
    console.error(e);
    throw e;
  } finally {
    await removeTempDir(tmpDir);
  }
}

async function _findNewFrames(tmpDir, frames, options) {
  const {
    streamInfo: {
      framerateFraction,
      timeCodeFirstFrame,
    },
    output: {
      bucket,
      framePrefix,
    },
  } = options;

  const dropFrame = isDropFrame(timeCodeFirstFrame);
  const enumFPS = framerateToEnum(framerateFraction);
  const timecodeFrameOffset = fromTimecode(enumFPS, timeCodeFirstFrame);

  frames.sort((a, b) =>
    a.frameNum - b.frameNum);

  let promises = [];

  for (const frame of frames) {
    const {
      frameNum,
      file,
    } = frame;
    // floor the timestamp to align the frame accurarcy
    frame.timestampMillis = Math.floor((frameNum * 1000 * framerateFraction[1]) / framerateFraction[0]);
    frame.smpteTimecode = toTimecode(enumFPS, (timecodeFrameOffset + frameNum), dropFrame)[0];

    const name = `${frameNum}.jpg`;
    const key = join(framePrefix, name);

    const stream = createReadStream(join(tmpDir, file));

    promises.push(uploadStream(bucket, key, stream)
      .then(() => {
        frame.name = name;
        delete frame.file;
      }));
  }

  await Promise.all(promises);

  return frames;
}

async function _analyzeSceneBoundary(params, boundary) {
  const {
    frames: [frameFrom, frameTo],
  } = boundary;

  const response = await _analyzeFrameBoundary(params, [frameFrom, frameTo]);
  const { newFrames, titanApiCount } = response;

  // patching the frame prefix
  for (const frame of newFrames) {
    frame.name = join('b', frame.name);
  }

  // reassign shot and scene ids
  const {
    filterSettings: {
      minFrameSimilarity,
    },
  } = params;

  const frameGroups = groupFramesToShots(newFrames, minFrameSimilarity);

  const lowerBound = frameFrom.frameNum;
  const upperBound = frameTo.frameNum;

  // reduce to two frames per group
  for (let i = 0; i < frameGroups.length; i += 1) {
    const frameGroup = frameGroups[i];
    if (frameGroup.length === 1) {
      frameGroups[i] = [frameGroup[0]];
    } else {
      frameGroups[i] = [frameGroup[0], frameGroup[frameGroup.length - 1]];
    }
  }

  let newSceneId = frameFrom.scene + 0.10;
  let newShotId = frameFrom.shot + 0.10;

  for (const frameGroup of frameGroups) {
    let sceneId;
    let shotId;
    // case 1: extending the "from" boundary
    if (frameGroup[0].frameNum === lowerBound) {
      sceneId = frameFrom.scene;
      shotId = frameFrom.shot;
    } else if (frameGroup[frameGroup.length - 1].frameNum === upperBound) {
      // case 2: extending the "to" boundary
      sceneId = frameTo.scene;
      shotId = frameTo.shot;
    } else {
      // case 3: new shot and scene...
      sceneId = newSceneId;
      shotId = newShotId;
      newSceneId += 0.10;
      newShotId += 0.10;
    }

    for (const frame of frameGroup) {
      frame.shot = shotId;
      frame.scene = sceneId;
    }
  }

  return { newFrames, titanApiCount };
}

async function _fetchLocalFiles(tmpDir, maxFrames = -1) {
  const frames = [];

  let files = await readdir(tmpDir);

  for (const file of files) {
    const { name, ext } = parse(file);

    if (ext !== '.jpg') {
      continue;
    }

    frames.push({
      file,
      frameNum: Number(name),
    });
  }

  frames.sort((a, b) =>
    a.frameNum - b.frameNum);

  if (maxFrames <= 0 || maxFrames >= frames.length) {
    return frames;
  }

  // evenly distribute the frames
  const selected = [];
  const step = Math.ceil(frames.length / (maxFrames + 1));

  for (let i = 1; i < frames.length; i += 1) {
    if ((i % step) === 0) {
      selected.push(frames[i]);
    }
    if (selected.length >= maxFrames) {
      break;
    }
  }

  return selected;
}

function _makeFFmpegCommand(url, ss, to, vf, output, offset = 3000) {
  let cmdOpts = [];

  // combine both fast seek and accurate seek
  let fastSS;
  let accurateSS = ss;
  let accurateTO = to;

  const minDuration = offset + 2000;
  if (ss && ss > minDuration) {
    // fast seek to 2s before the actual frame
    fastSS = ss - offset;
    accurateSS = offset;
    accurateTO = to - ss + offset;
  }

  // fast seek option
  if (fastSS && fastSS > 0) {
    cmdOpts = cmdOpts.concat(['-ss', (fastSS / 1000).toFixed(3)]);
  }

  // input url
  cmdOpts = cmdOpts.concat(['-i', url]);

  // accurate seek option
  if (accurateSS && accurateSS > 0) {
    cmdOpts = cmdOpts.concat(['-ss', (accurateSS / 1000).toFixed(3)]);
  }

  // to option
  if (accurateTO && accurateTO > 0) {
    cmdOpts = cmdOpts.concat(['-to', (accurateTO / 1000).toFixed(3)]);
  }

  // video filters (optional)
  if (vf && vf.length > 0) {
    cmdOpts = cmdOpts.concat(['-vf', vf.join(',')]);
  }

  // output settings
  cmdOpts = cmdOpts.concat([
    '-fps_mode', 'passthrough',
    '-qmin', String(1),
    '-q:v', String(1),
  ]);

  cmdOpts.push(output);

  return cmdOpts;
}

async function _waitAndCheckExceptions(promises) {
  let exception;

  const responses = await Promise.all(promises);
  for (const response of responses) {
    if (response !== undefined) {
      exception = response;
      break;
    }
  }

  return exception;
}

////////////////////////////////////////////////////
// Functions to export
////////////////////////////////////////////////////
async function analyzeFrameBoundary(params, boundary, maxFrames) {
  return _analyzeFrameBoundary(params, boundary, maxFrames);
}

async function analyzeSceneBoundary(params, boundary) {
  return _analyzeSceneBoundary(params, boundary);
}

module.exports = {
  // definitions
  ...DEFINITIONS,
  // smpte IMF definition
  CompositionPlaylist,
  // methods
  // model configuration
  loadModelConfigs,
  getPreferredModel,
  // frame level
  createSequenceImage,
  computeFrameProperties,
  frameGroupAttributes,
  tagAudioMetadataToFrames,
  // frames to shots
  groupFramesToShots,
  shotGroupAttributes,
  verifyFramesAndShots,
  tagAudioMetadataToShots,
  // shots to scenes
  groupShotsToScenes,
  sceneGroupAttributes,
  verifyShotsAndScenes,
  // boundary frames
  analyzeFrameBoundary,
  analyzeSceneBoundary,
  // clustering
  agnesClusterFramesToScenes,
};
