// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const anyBase = require('any-base');
const {
  getSignedUrl,
  download,
  headObject,
} = require('./commonUtils');
const {
  findColor,
} = require('./colorHelper');
const {
  MAXPIXELTHRESHOLD,
  MINCOVERAGEPERCENTAGE,
} = require('./segmentHelper/definitions');

let Jimp;

const alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';
const toBinary = anyBase(alphabet, anyBase.BIN);

const MONOCHROME_LUMINANCE_TOLERANCE = 2.0001;
const BLACKFRAME_HASH = '0';
const LaplacianKernel = [
  [0, 1, 0],
  [1, -4, 1],
  [0, 1, 0],
];

const DEFAULT_IMAGEWXH = [1920, 1080];
const BORDERSIZE = 2;
const BORDERCOLOR = 0xffffffff; // white border

class JimpHelper {
  static get MIME_JPEG() {
    return 'image/jpeg';
  }

  static get MIME_PNG() {
    return 'image/png';
  }

  static async loadImage(bucket, key) {
    const image = await _loadImage(bucket, key);
    return image;
  }

  static async imageFromS3(bucket, key) {
    const image = await _imageFromS3(bucket, key);
    return image;
  }

  static async imageFromBuffer(buf) {
    const jimpLib = _getJimpLib();
    return jimpLib.read(buf);
  }

  static async imageFromScratch(w, h, color) {
    const image = await _imageFromScratch(w, h, color);
    return image;
  }

  static drawBorder(image, x, y, w, h, borderSize, borderColor) {
    return _drawBorder(image, x, y, w, h, borderSize, borderColor);
  }

  static computeHash(image) {
    return image.hash();
  }

  static computeLaplacianVariance(image) {
    return _computeLaplacianVariance(image);
  }

  static compareHashes(a, b) {
    return _compareHashes(a, b);
  }

  static computeBlackLevel(image, options) {
    return _computeBlackLevel(image, options);
  }

  static distanceToBlack(hash) {
    return _compareHashes(hash, BLACKFRAME_HASH);
  }

  static compareImagePixels(a, b) {
    return _compareImagePixels(a, b);
  }

  static async tileImage(images, maxWxH, borderSize, borderColor) {
    const response = await _tileImage(images, maxWxH, borderSize, borderColor);
    return response;
  }

  static cropFace(image, box, dimension, scaleBox) {
    return _cropFace(image, box, dimension, scaleBox);
  }

  static drawGrid(image, nRow, nCol, borderSize, borderColor) {
    return _drawGrid(image, nRow, nCol, borderSize, borderColor);
  }
}

//
// Dynamically load jimp library and apply JpegDecoder patch
//
// WORKAROUND: JIMP 0.16.1 (0.9.6 doesn't have the issue.)
// jpeg-js decoder throws an error when maxMemoryUsageInMB > 512
// Reference: https://github.com/oliver-moran/jimp/issues/915
//
function _getJimpLib() {
  if (Jimp === undefined) {
    try {
      Jimp = require('jimp');
      return _patchJpegDecoder(Jimp);
    } catch (e) {
      Jimp = e;
    }
  }

  if (Jimp instanceof Error) {
    throw Jimp;
  }
  return Jimp;
}

function _patchJpegDecoder(jimpLib) {
  const JpegDecoder = jimpLib.decoders['image/jpeg'];

  jimpLib.decoders['image/jpeg'] = (data) =>
    JpegDecoder(data, {
      maxResolutionInMP: 200,
      maxMemoryUsageInMB: 2048,
    });

  return jimpLib;
}

async function _loadImage(bucket, key) {
  const jimpLib = _getJimpLib();

  let retries = 2;
  do {
    try {
      const signed = await getSignedUrl({
        Bucket: bucket,
        Key: key,
      });

      const image = await jimpLib.read(signed);

      return image;
    } catch (e) {
      e;
      await _pause();
    }
  } while ((retries--) > 0);

  throw new Error(`JimpHelper: fail to load image from s3://${bucket}/${key}`);
}

async function _imageFromS3(bucket, key) {
  try {
    let image = await _loadImage(bucket, key)
      .catch(() => undefined);

    if (image) {
      return image;
    }

    // see if the file actually exists
    await headObject(bucket, key);

    // download and load image from buffer
    image = await download(bucket, key, false)
      .then((res) =>
        res.Body.transformToByteArray());
    image = await image;

    const jimpLib = _getJimpLib();
    image = await jimpLib.read(Buffer.from(image));

    return image;
  } catch (e) {
    console.log(e);
    throw new Error(`imageFromS3 failed to load ${key}`);
  }
}

async function _imageFromScratch(w, h, color = BORDERCOLOR) {
  let promise = new Promise((resolve, reject) => {
    const jimpLib = _getJimpLib();
    const ignored = new jimpLib(w, h, color, (e, img) => {
      if (e) {
        reject(e);
      } else {
        resolve(img);
      }
    });
    ignored;
  });

  promise = await promise;

  return promise;
}

function _drawBorder(image, x, y, w, h, borderSize = BORDERSIZE, borderColor = BORDERCOLOR) {
  const imgW = image.bitmap.width;
  const imgH = image.bitmap.height;

  const x1 = (Math.max(x, 0) >> 1) << 1;
  const y1 = (Math.max(y, 0) >> 1) << 1;

  let w1 = w;
  if ((x1 + w1 + borderSize) > imgW) {
    w1 = ((imgW - x1 - borderSize) >> 1) << 1;
  }

  let h1 = h;
  if ((y1 + h1 + borderSize) > imgH) {
    h1 = ((imgH - y1 - borderSize) >> 1) << 1;
  }

  const coords = [
    [x1, y1, w1, borderSize],
    [x1, y1 + h1, w1, borderSize],
    [x1, y1, borderSize, h1],
    [x1 + w1, y1, borderSize, h1],
  ];

  for (const coord of coords) {
    image.scan(...coord, (x0, y0, offset) => {
      image.bitmap.data.writeUInt32BE(borderColor, offset, true);
    });
  }

  return image;
}

function _compareHashes(a, b) {
  const jimpLib = _getJimpLib();
  const binA = toBinary(a).padStart(64, '0');
  const binB = toBinary(b).padStart(64, '0');
  return jimpLib.compareHashes(binA, binB);
}

function _computeLaplacianVariance(image) {
  const singleChannel = [];
  let sum = 0;

  const tmp = image
    .clone()
    .convolute(LaplacianKernel);

  tmp.scan(0, 0, tmp.bitmap.width, tmp.bitmap.height, (px, py, idx) => {
    const rgba = tmp.bitmap.data;
    const r = rgba[idx + 0];
    const g = rgba[idx + 1];
    const b = rgba[idx + 2];

    const weighted = (r * 0.299) + (g * 0.587) + (b * 0.114);
    singleChannel.push(weighted);
    sum += weighted;
  });

  const mean = sum / singleChannel.length;

  let variance = (singleChannel
    .reduce((a, c) =>
      a + (c - mean) ** 2, 0));

  variance /= (singleChannel.length - 1);

  return Math.round(variance);
}

function _computeBlackLevel(image, options = {}) {
  try {
    let {
      maxPixelThreshold = MAXPIXELTHRESHOLD,
      minCoveragePercentage = MINCOVERAGEPERCENTAGE,
    } = options;

    // compute luminance level
    const imgW = image.bitmap.width;
    const imgH = image.bitmap.height;

    const totalPixels = imgW * imgH;
    const maxBlackLuminance = 0 + (maxPixelThreshold * (255 - 0));
    const minPixelCoverage = Math.round(
      (minCoveragePercentage * totalPixels) / 100
    );

    let absBlackPixels = 0;
    let blackPixels = 0;

    const luminances = [];
    let luminanceSum = 0;
    let luminanceRange = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];

    let Rsum = 0;
    let Gsum = 0;
    let Bsum = 0;

    image.scan(0, 0, imgW, imgH, (px, py, idx) => {
      const rgba = image.bitmap.data;
      const R = rgba[idx + 0];
      const G = rgba[idx + 1];
      const B = rgba[idx + 2];

      Rsum += R;
      Gsum += G;
      Bsum += B;

      const luminance = (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
      luminanceRange = [Math.min(luminance, luminanceRange[0]), Math.max(luminance, luminanceRange[1])];
      luminanceSum += luminance;
      luminances.push(luminance);

      if (luminance === 0) {
        absBlackPixels += 1;
      }

      if (luminance <= maxBlackLuminance) {
        blackPixels += 1;
      }
    });

    const blackCoveragePercentage = (blackPixels / totalPixels) * 100;
    const isBlack = (blackPixels >= minPixelCoverage);

    const luminanceMean = luminanceSum / totalPixels;

    let isMonochrome = false;
    if (
      !isBlack &&
      (Math.abs(luminanceRange[0] - luminanceMean) < MONOCHROME_LUMINANCE_TOLERANCE) &&
      (Math.abs(luminanceRange[1] - luminanceMean) < MONOCHROME_LUMINANCE_TOLERANCE)
    ) {
      isMonochrome = true;
    }

    const luminanceMinMaxMean = [
      ...luminanceRange,
      luminanceMean,
    ];

    const dominantColor = [
      Math.round(Rsum / totalPixels),
      Math.round(Gsum / totalPixels),
      Math.round(Bsum / totalPixels),
    ];
    const dominantColorName = findColor(dominantColor).name;

    return {
      isBlack,
      isMonochrome,
      absBlackPixels,
      blackPixels,
      blackCoveragePercentage,
      wxh: [imgW, imgH],
      luminanceMinMaxMean,
      dominantColor,
      dominantColorName,
      minCoveragePercentage,
      maxPixelThreshold,
    };
  } catch (e) {
    console.log(e);
    return undefined;
  }
}

function _compareImagePixels(a, b) {
  const jimpLib = _getJimpLib();
  return jimpLib.diff(a, b);
}

async function _tileImage(images, maxWxH = DEFAULT_IMAGEWXH, borderSize = BORDERSIZE, borderColor = BORDERCOLOR) {
  if (images.length === 0 && images[0].length === 0) {
    return [];
  }

  const nRow = images.length;
  const nCol = Math.max(...images.map((x) => x.length));

  const w = images[0][0].bitmap.width;
  const h = images[0][0].bitmap.height;

  const totalW = w * nCol;
  const totalH = h * nRow;

  const factor = Math.max(totalW / maxWxH[0], totalH / maxWxH[1]);

  const tileW = (Math.floor(w / factor) >> 1) << 1;
  const tileH = (Math.floor(h / factor) >> 1) << 1;

  const compositeW = ((tileW * nCol) >> 1) << 1;
  const compositeH = ((tileH * nRow) >> 1) << 1;

  const compositeImage = await _imageFromScratch(compositeW, compositeH);

  const coords = [];

  for (let i = 0; i < nRow; i += 1) {
    coords[i] = [];
    for (let j = 0; j < nCol; j += 1) {
      const t = i * tileH;
      const l = j * tileW;
      const image = images[i][j].resize(tileW, tileH);
      compositeImage.blit(image, l, t);
      coords[i].push([t, l, tileW, tileH]);
    }
  }

  // draw border
  let xywh;
  const lineSize = Math.ceil(borderSize / 2);
  for (let i = 1; i < nRow; i += 1) {
    xywh = [0, (i * tileH) - lineSize, compositeW, lineSize * 2];
    compositeImage.scan(...xywh, (x0, y0, offset) => {
      compositeImage.bitmap.data.writeUInt32BE(borderColor, offset, true);
    });

    for (let j = 1; j < nCol; j += 1) {
      xywh = [(j * tileW) - lineSize, 0, lineSize * 2, compositeH];
      compositeImage.scan(...xywh, (x0, y0, offset) => {
        compositeImage.bitmap.data.writeUInt32BE(borderColor, offset, true);
      });
    }
  }

  return [compositeImage, coords];
}

async function _pause(milliseconds = 200) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, milliseconds);
  });
}

function _cropFace(image, box, dimension = [1, 1], scaleBox = 1.50) {
  // crop face
  const imgW = image.bitmap.width;
  const imgH = image.bitmap.height;

  let { l, t, w, h } = box;
  l = Math.round(l * imgW);
  t = Math.round(t * imgH);
  w = (Math.round(w * imgW) >> 1) << 1;
  h = (Math.round(h * imgH) >> 1) << 1;

  // factor in aspect ratio (3:4)
  const aspectRatio = dimension[0] / dimension[1];
  let arW = (Math.round(h * aspectRatio) >> 1) << 1;
  let arH = (Math.round(w / aspectRatio) >> 1) << 1;
  if (arW > w) {
    arH = (Math.round(arW / aspectRatio) >> 1) << 1;
  } else {
    arW = (Math.round(arH * aspectRatio) >> 1) << 1;
  }

  // scale the bounding box
  let scaleW = Math.min(imgW, (Math.round(arW * scaleBox) >> 1) << 1);
  let scaleH = Math.min(imgH, (Math.round(arH * scaleBox) >> 1) << 1);

  // portriat mode, large face
  if (scaleW === imgW && imgW <= imgH) {
    scaleH = (Math.round(scaleW / aspectRatio) >> 1) << 1;
  }
  // landscape mode, large face
  if (scaleH === imgH && imgH <= imgW) {
    scaleW = (Math.round(scaleH * aspectRatio) >> 1) << 1;
  }

  l = Math.max(0, l - Math.ceil((scaleW - w) / 2));
  t = Math.max(0, t - Math.ceil((scaleH - h) / 2));
  w = scaleW;
  h = scaleH;

  // check out of bound
  if ((l + w) > imgW) {
    w = imgW - l;
  }
  if ((t + h) > imgH) {
    h = imgH - t;
  }

  let cropped = image.clone()
    .crop(l, t, w, h);

  if (dimension[0] !== 1 && dimension[1] !== 1) {
    cropped = cropped.resize(...dimension);
  }

  return cropped;
}

function _drawGrid(img, nRow, nCol, borderSize = BORDERSIZE, borderColor = BORDERCOLOR) {
  const imgW = img.bitmap.width;
  const imgH = img.bitmap.height;

  const tileH = Math.floor(imgH / nRow);
  const tileW = Math.floor(imgW / nCol);

  // draw border
  let xywh;
  const lineSize = Math.ceil(borderSize / 2);
  for (let i = 1; i < nRow; i += 1) {
    xywh = [0, (i * tileH) - lineSize, imgW, lineSize * 2];
    img.scan(...xywh, (x0, y0, offset) => {
      img.bitmap.data.writeUInt32BE(borderColor, offset, true);
    });
  }

  for (let j = 1; j < nCol; j += 1) {
    xywh = [(j * tileW) - lineSize, 0, lineSize * 2, imgH];
    img.scan(...xywh, (x0, y0, offset) => {
      img.bitmap.data.writeUInt32BE(borderColor, offset, true);
    });
  }

  return img;
}

module.exports = JimpHelper;
