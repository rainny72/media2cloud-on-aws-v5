// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const PATH = require('node:path');
const {
  download,
  listObjects,
} = require('./commonUtils');
const {
  getIABTaxonomies,
  getGARMTaxonomies,
  getSentiments,
  getUSTVRatings,
  getMPAARatings,
} = require('./taxonomies/taxonomyHelper');

// loading hierarchy
// _promptTemplate/[formtype]/[level]/[system.tmpl|*.json]
// _promptTemplate/[formtype]/[system.tmpl|*.json]
// _promptTemplate/[system.tmpl|*.json]
// ex. _promptTemplate/long/clip/system.tmpl
// ex. _promptTemplate/short/clip/system.tmpl
// ex. _promptTemplate/short/frame/system.tmpl
// ex. _promptTemplate/short/system.tmpl
// ex. _promptTemplate/system.tmpl
const TEMPLATE_ROOT = '_promptTemplates';
const FORMTYPE_IMAGE = 'image';
const FORMTYPE_DOCUMENT = 'document';
const FORMTYPE_SHORT = 'short';
const FORMTYPE_LONG = 'long';
const LEVEL_CLIP = 'clip';
const LEVEL_FRAME = 'frame';
const LEVEL_SCENE = 'scene';
const LEVEL_SHOT = 'shot';

const enumLevels = {
  ClipLevel: Symbol(LEVEL_CLIP),
  FrameLevel: Symbol(LEVEL_FRAME),
  SceneLevel: Symbol(LEVEL_SCENE),
  ShotLevel: Symbol(LEVEL_SHOT),
};

const enumFormTypes = {
  LongForm: Symbol(FORMTYPE_LONG),
  ShortForm: Symbol(FORMTYPE_SHORT),
  ImageForm: Symbol(FORMTYPE_IMAGE),
  DocumentForm: Symbol(FORMTYPE_DOCUMENT),
};

// default system prompt
const SYSTEM_DEFAULT_SCENE_AND_SHOT = `
You are a media analyst tasked with reviewing video content. The video will be presented to you as a sequence of images, with each image containing a grid of screenshot frames taken from the video. You should review the frames in each image from left to right and top to bottom before moving to the next image. This sequence of images represents a scene from the video.

Additionally, you may be provided with a transcript of the dialogue from the scene to provide additional context.

Before providing any analysis, you must carefully examine all of the screenshot frames across the entire sequence of images. If a transcript is provided, you must also read through the full transcript.

After thoroughly reviewing the material, here are the tasks you should complete along with a confidence score from 0 to 100 for each task. If you don't know the answer to any task, respond with 'None':

{{TASK_LIST}}

{{DEFINITIONS}}
`;

const SYSTEM_DEFAULT_SHORT_CLIP = `
You are a media analyst tasked with reviewing short-form video content. The video will be presented to you as a list of images, with each image containing a grid of screenshot frames taken from the video. You must review the frames in each image from left to right and top to bottom before moving to the next image in the sequence. This sequence of images represents the entire short video.

Additionally, you may be provided with a transcript of the dialogue from the video and a list of known people who appear in the video to provide additional context.

Before providing any analysis, you must carefully examine all of the screenshot frames across the entire sequence of images. If a transcript or list of people is provided, you must also thoroughly review those materials.

After reviewing the content, here are the tasks you should complete along with a confidence score from 0 to 100 for each task. If you don't know the answer to any task, respond with 'None':

{{TASK_LIST}}

{{DEFINITIONS}}

Provide confidence score from 0 to 100 for each task. If you don't know the answer to any of the tasks, answer 'None'.
`;

const SYSTEM_DEFAULT_FRAME = `
You are a Quality Assurance Engineer reviewing a set of images extracted from a short video content. Your tasks are as follows:

For each image:

1. Carefully analyze the image for any unsafe or offensive content such as explicit violence, hate speech, illegal activities, etc.

- If unsafe content is present, flag the image as "Unsafe" and provide a brief reasoning.


2. Proceed to answer the following questions for the image, regardless of whether unsafe content is present:

{{TASK_LIST}}

If you cannot determine an answer for any question, respond with "None" for that question.

You must review and analyze each image individually in the sequence provided before moving to the next image.

{{DEFINITIONS}}

Provide confidence score from 0 to 100 for each task. If you don't know the answer to any of the tasks, answer 'None'.
`;

// Built-in default tasks
const TASK_DESCRIPTION = 'description';
const TASK_IAB = 'iabTaxonomy';
const TASK_GARM = 'garmTaxonomy';
const TASK_USTV_RATING = 'ustvRating';
const TASK_MPAA_RATING = 'mpaaRating';
const TASK_SENTIMENT = 'sentiment';
const TASK_BRANDS_LOGOS = 'brandsAndLogos';
const TASK_TAGS = 'tags';
const TASK_CAMERA_SHOT_EVENTS = 'cameraShotEvents';

const BUILT_IN_TASKS = [
  // {
  //   name: 'emotion',
  //   task: 'From the <emotion> list. Identify the emotion for the content and provide a confidence score.',
  //   list: [
  //     'Happy',
  //     'Sad',
  //     'Disgust',
  //   ],
  //   example: {
  //     emotion: {
  //       text: 'Happy',
  //       score: 98,
  //     },
  //   },
  //   metaInstructions: [
  //     {
  //       name: 'guidelines', // Correspond to {{GUIDELINES}} meta field in system prompt
  //       desc: 'Additional guidelines for identifying "emotion" tag:',
  //       list: [
  //         'Character(s) must clearly show his/her facial expression',
  //       ],
  //     },
  //   ],
  // },
  {
    name: TASK_DESCRIPTION,
    task: 'Provide a detailed description of the content depicted in the video frames and transcript, and a confidence score.',
    list: undefined,
    example: {
      [TASK_DESCRIPTION]: {
        text: 'Blah...',
        score: 98,
      },
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_IAB,
    task: `From the <${TASK_IAB}> list, identify the top relevant category for the content and provide a confidence score. The category in this list are arranged in descending order of priority.`,
    list: getIABTaxonomies(),
    example: {
      [TASK_IAB]: {
        text: 'Attractions',
        score: 80,
      },
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_GARM,
    task: `From the <${TASK_GARM}> list, identify the top relevant category for the content and provide a confidence score.`,
    list: getGARMTaxonomies(),
    example: {
      [TASK_GARM]: {
        text: 'Online piracy',
        score: 90,
      },
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_USTV_RATING,
    task: `Identify the top US TV rating provided in <${TASK_USTV_RATING}> tag. Only answer from the list.`,
    list: getUSTVRatings(),
    example: {
      [TASK_USTV_RATING]: {
        text: 'TV-Y7-FV',
        score: 90,
      },
    },
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_SHORT, LEVEL_CLIP),
    ],
  },
  {
    name: TASK_MPAA_RATING,
    task: `Identify the top Motion Picture Association (MPAA) rating provided in <${TASK_MPAA_RATING}> tag. Only answer from the list.`,
    list: getMPAARatings(),
    example: {
      [TASK_MPAA_RATING]: {
        text: 'PG',
        score: 90,
      },
    },
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_SHORT, LEVEL_CLIP),
    ],
  },
  {
    name: TASK_SENTIMENT,
    task: `From the <${TASK_SENTIMENT}> list, identify the overall sentiment expressed in the content and provide a confidence score.`,
    list: getSentiments(),
    example: {
      [TASK_SENTIMENT]: {
        text: 'Positive',
        score: 90,
      },
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_BRANDS_LOGOS,
    task: 'Identify up to ten brands and logos that appear in the video frames or transcript, and provide a confidence score.',
    list: undefined,
    example: {
      [TASK_BRANDS_LOGOS]: [
        {
          text: 'Amazon',
          score: 98,
        },
      ],
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_TAGS,
    task: 'Identify five relevant tags to describe the key themes or topics in the video content and provide a confidence score.',
    list: undefined,
    example: {
      [TASK_TAGS]: [
        {
          text: 'music video',
          score: 90,
        },
      ],
    },
    installPaths: [
      TEMPLATE_ROOT,
    ],
  },
  {
    name: TASK_CAMERA_SHOT_EVENTS,
    task: 'Describes what happens within each camera shots.',
    list: undefined,
    example: {
      [TASK_CAMERA_SHOT_EVENTS]: [
        {
          text: 'Blah...',
          score: 80,
        },
      ],
    },
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_SHORT, LEVEL_CLIP),
    ],
  }
];

const BUILT_IN_SYSTEMS = [
  {
    name: 'system',
    desc: 'Shortform, frame level system prompt',
    system: SYSTEM_DEFAULT_FRAME,
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_SHORT, LEVEL_FRAME),
    ],
  },
  {
    name: 'system',
    desc: 'Shorform, clip level system prompt',
    system: SYSTEM_DEFAULT_SHORT_CLIP,
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_SHORT, LEVEL_CLIP),
    ],
  },
  {
    name: 'system',
    desc: 'Longform, scene and shot level system prompt',
    system: SYSTEM_DEFAULT_SCENE_AND_SHOT,
    installPaths: [
      PATH.join(TEMPLATE_ROOT, FORMTYPE_LONG),
    ],
  },
];

class TaskManager {
  constructor(formType, level, customSystem = '') {
    if (customSystem.length > 0) {
      this.$system = customSystem;
    } else {
      const {
        ClipLevel,
        FrameLevel,
        SceneLevel,
        ShotLevel,
      } = enumLevels;
      const {
        LongForm,
        ShortForm,
      } = enumFormTypes;

      if (formType === LongForm) {
        if (level === SceneLevel || level === ShotLevel) {
          this.$system = SYSTEM_DEFAULT_SCENE_AND_SHOT;
        }
      } else if (formType === ShortForm) {
        if (level === ClipLevel) {
          this.$system = SYSTEM_DEFAULT_SHORT_CLIP;
        } else if (level === FrameLevel) {
          this.$system = SYSTEM_DEFAULT_FRAME;
        }
      }
    }

    if (!this.$system) {
      throw new Error('TaskManager constructor missing input parameters');
    }
    this.$formType = formType;
    this.$level = level;
    this.$availableTasks = [];
  }

  get system() {
    return this.$system;
  }

  set system(val) {
    this.$system = val;
  }

  get formType() {
    return this.$formType;
  }

  get level() {
    return this.$level;
  }

  get availableTasks() {
    return this.$availableTasks;
  }

  set availableTasks(val) {
    this.$availableTasks = val;
  }

  getSystem() {
    return this.system;
  }

  getAvailableTasks() {
    return this.availableTasks;
  }

  getAvailableTaskNames() {
    return this.availableTasks
      .map((x) => x.name);
  }

  resolveSystem(_tasks = []) {
    let tasks = _tasks;

    if (tasks.length === 0) {
      tasks = this.availableTasks;
    }

    if (tasks.length === 0) {
      throw new Error('Expects tasks to be present');
    }

    let taskList = [];
    let definitionList = [];

    for (const task of tasks) {
      taskList.push(`- ${task.task}`);

      if (Array.isArray(task.list) && task.list.length > 0) {
        const name = task.name;
        const items = task.list.map((item, idx) =>
          `${idx + 1}. ${item}`);

        const definitions = [
          `<${name}>`,
          ...items,
          `</${name}>`,
        ];
        definitionList.push(definitions.join('\n'));
      }
    }

    let system = this.system
      .replace('{{TASK_LIST}}', taskList.join('\n'))
      .replace('{{DEFINITIONS}}', definitionList.join('\n\n'));

    // meta instructions
    const metaInstructions = _resolveMetaInstructions(tasks);

    for (const key in metaInstructions) {
      if (Array.isArray(metaInstructions[key]) && metaInstructions[key].length > 0) {
        const re = new RegExp(`{{${key}}}`);
        const instruction = metaInstructions[key].join('\n\n');
        system = system.replace(re, instruction);
      }
    }

    // remove any meta instruction that is not processed
    const matched = system.match(/({{[a-zA-Z0-9_]+}})/g);
    if (matched) {
      for (const match of matched) {
        const re = new RegExp(match, 'g');
        system = system.replace(re, '');
      }
    }

    // console.log(system);
    return system;
  }

  async load(bucket) {
    try {
      const pathRef = PATH.join(
        TEMPLATE_ROOT,
        this.formType.description,
        this.level.description,
      )

      const keys = await listObjects(bucket, TEMPLATE_ROOT)
        .then((res) =>
          res.Contents
            .map((x) =>
              x.Key))
        .catch(() => []);

      const systems = [];
      const tasks = {};

      for (const key of keys) {
        const path = PATH.parse(key);
        // keys must be in the path hiechary
        if (pathRef.indexOf(path.dir) !== 0) {
          continue;
        }
        if (path.ext === '.tmpl') {
          systems.push(key);
        } else if (path.ext === '.json') {
          if (tasks[path.name] === undefined) {
            tasks[path.name] = [];
          }
          tasks[path.name].push(key);
        }
      }

      // sort system in hierchary order
      systems.sort((a, b) =>
        b.length - a.length);

      let system;
      while (systems.length) {
        system = systems.shift();
        system = await download(bucket, system)
          .then((res) =>
            res.toString())
          .catch(() => undefined);

        if (system !== undefined) {
          this.system = system;
          break;
        }
      }

      // sort individual task in hierchary order
      const availableTasks = [];

      for (const name in tasks) {
        tasks[name].sort((a, b) =>
          b.length - a.length);

        while (tasks[name].length) {
          let task = tasks[name].shift();
          task = await download(bucket, task)
            .then((res) =>
              JSON.parse(res.toString()))
            .catch(() => undefined);

          if (_validateTaskSpec(task)) {
            availableTasks.push(task);
            break;
          }
        }
      }

      this.availableTasks = availableTasks;

      // true - ready to use
      return true;
    } catch (e) {
      e;
      return false;
    }
  }

  taskSupported(name) {
    return (this.getTaskByName(name) !== undefined)
  }

  getTaskByName(name) {
    return this.availableTasks
      .find((x) =>
        x.name === name);
  }

  getTasksByNames(names = []) {
    return this.availableTasks
      .filter((x) =>
        names.includes(x.name));
  }
}

function _validateTaskSpec(task) {
  if (typeof task !== 'object' || task === null) {
    return false;
  }

  // must be a json object
  if (Array.isArray(task)) {
    return false;
  }

  // mandatory fields must exist
  const fields = Object.keys(task);
  let pass = ['name', 'task', 'example']
    .every((name) =>
      fields.includes(name));
  if (!pass) {
    return false;
  }

  // example must also be a json object
  if (typeof task.example !== 'object' || task.example === null) {
    return false;
  }
  if (Array.isArray(task.example)) {
    return false;
  }

  // if list is specified, it must be a list of strings
  if (task.list) {
    if (!Array.isArray(task.list)) {
      return false;
    }

    pass = task.list
      .every((item) =>
        typeof item === 'string');

    if (!pass) {
      return false;
    }
  }

  return true;
}

function _resolveMetaInstructions(tasks) {
  const instructions = {};

  for (const task of tasks) {
    if (!Array.isArray(task.metaInstructions) || task.metaInstructions.length === 0) {
      continue;
    }

    for (const metaInstruction of task.metaInstructions) {
      const {
        name,
        desc,
        list,
      } = metaInstruction;

      if (typeof name !== 'string' || name.length === 0) {
        continue;
      }

      if (typeof desc !== 'string' || desc.length === 0) {
        continue;
      }

      if (!Array.isArray(list) || list.length === 0) {
        continue;
      }

      let listItems = list.filter((item) =>
        typeof item === 'string' && item.length > 0);

      if (listItems.length === 0) {
        continue;
      }

      // create a number list
      listItems = listItems.map((item, i) =>
        `${i + 1}. ${item}`);

      const instruction = [
        desc,
        ...listItems,
        ''
      ].join('\n');

      const key = name.toUpperCase();
      if (instructions[key] === undefined) {
        instructions[key] = []
      }

      instructions[key].push(instruction);
    }
  }

  return instructions;
}

function GetBuiltinSystems() {
  return BUILT_IN_SYSTEMS;
}

function GetBuiltinTasks() {
  return BUILT_IN_TASKS;
}

function GetBuiltinTaskNames() {
  return BUILT_IN_TASKS
    .map((x) => x.name);
}

function GetBuiltinTaskByName(name) {
  return BUILT_IN_TASKS
    .find((x) =>
      x.name === name);
}

function toEnumLevel(str = '') {
  for (const level of Object.values(enumLevels)) {
    if (level.description === str) {
      return level;
    }
  }
  return undefined;
}

function toEnumFormType(str = '') {
  for (const formType of Object.values(enumFormTypes)) {
    if (formType.description === str) {
      return formType;
    }
  }
  return undefined;
}

module.exports = {
  GetBuiltinSystems,
  GetBuiltinTasks,
  GetBuiltinTaskNames,
  GetBuiltinTaskByName,
  toEnumLevel,
  toEnumFormType,
  enumLevels,
  enumFormTypes,
  TaskManager,
};
